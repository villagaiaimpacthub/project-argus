<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Claude Code - Real-Time Monitoring Dashboard</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            color: #e8e6e3;
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.05);
        }
        
        .header h1 { 
            font-size: 2.2em; 
            margin-bottom: 8px;
            background: linear-gradient(45deg, #00f5ff, #8b5cf6, #06ffa5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }
        
        .header p { 
            font-size: 1em; 
            opacity: 0.7;
            color: #a8a8a8;
        }
        
        .workspace-info {
            margin-top: 15px;
            padding: 12px 20px;
            background: rgba(0,245,255,0.08);
            border: 1px solid rgba(0,245,255,0.2);
            border-radius: 8px;
            text-align: left;
        }
        
        .workspace-path {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }
        
        .workspace-label {
            font-size: 0.9em;
            color: #00f5ff;
            font-weight: 500;
            min-width: 80px;
        }
        
        .workspace-value {
            font-size: 0.9em;
            color: #ffffff;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: rgba(0,0,0,0.3);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.2s ease;
            title: "Click to copy path";
        }
        
        .workspace-value:hover {
            background: rgba(0,245,255,0.1);
            border-color: rgba(0,245,255,0.3);
        }
        
        .workspace-details {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .project-type {
            font-size: 0.8em;
            color: #8b5cf6;
            font-weight: 500;
            background: rgba(139,92,246,0.1);
            padding: 2px 8px;
            border-radius: 12px;
            border: 1px solid rgba(139,92,246,0.3);
        }
        
        .change-workspace-btn {
            background: rgba(0,245,255,0.1);
            border: 1px solid rgba(0,245,255,0.3);
            color: #00f5ff;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 0.8em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 10px;
        }
        
        .change-workspace-btn:hover {
            background: rgba(0,245,255,0.2);
            border-color: rgba(0,245,255,0.5);
            transform: translateY(-1px);
        }
        
        /* Modal Styles */
        .workspace-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid rgba(0,245,255,0.3);
            border-radius: 16px;
            padding: 0;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
            animation: slideInUp 0.3s ease;
        }
        
        .modal-header {
            background: linear-gradient(90deg, rgba(0,245,255,0.1), rgba(139,92,246,0.1));
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .modal-header h3 {
            color: #ffffff;
            margin: 0;
            font-size: 1.2em;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: #ff4757;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .modal-close:hover {
            background: rgba(255,71,87,0.1);
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .modal-body p {
            color: #a8a8a8;
            margin-bottom: 15px;
        }
        
        .directory-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .directory-input {
            flex: 1;
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            padding: 10px 12px;
            color: #ffffff;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .directory-input:focus {
            outline: none;
            border-color: rgba(0,245,255,0.5);
            box-shadow: 0 0 0 2px rgba(0,245,255,0.1);
        }
        
        .browse-btn {
            background: rgba(139,92,246,0.1);
            border: 1px solid rgba(139,92,246,0.3);
            color: #8b5cf6;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        .browse-btn:hover {
            background: rgba(139,92,246,0.2);
            border-color: rgba(139,92,246,0.5);
        }
        
        .directory-browser {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            width: 90vw !important;
            max-width: 800px !important;
            height: 70vh !important;
            max-height: 600px !important;
            background: rgba(0,0,0,0.95) !important;
            backdrop-filter: blur(20px) !important;
            border-radius: 12px !important;
            border: 1px solid rgba(255,255,255,0.2) !important;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5) !important;
            overflow: hidden !important;
            flex-direction: column !important;
            z-index: 2147483647 !important;
            isolation: isolate !important;
            contain: layout style paint !important;
            pointer-events: auto !important;
        }
        
        .directory-browser[style*="display: none"] {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
        
        .directory-browser[style*="display: block"] {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        .browser-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 15px;
            background: rgba(255,255,255,0.05);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            min-height: 40px;
            position: relative;
            z-index: 2147483647 !important;
        }
        
        .breadcrumb-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }
        
        .drives-btn, .refresh-btn {
            background: rgba(139,92,246,0.1);
            border: 1px solid rgba(139,92,246,0.3);
            color: #8b5cf6;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .drives-btn:hover, .refresh-btn:hover {
            background: rgba(139,92,246,0.2);
            border-color: rgba(139,92,246,0.5);
        }
        
        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.8em;
        }
        
        .breadcrumb-item {
            color: #00f5ff;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            transition: background 0.2s ease;
        }
        
        .breadcrumb-item:hover {
            background: rgba(0,245,255,0.1);
        }
        
        .breadcrumb-item:not(:last-child)::after {
            content: " ‚Ä∫ ";
            color: #a8a8a8;
            margin-left: 4px;
        }
        
        .browser-sidebar {
            width: 160px;
            background: rgba(255,255,255,0.02);
            border-right: 1px solid rgba(255,255,255,0.1);
            padding: 10px 0;
            overflow-y: auto;
        }
        
        .browser-main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .section-title {
            padding: 8px 12px 4px;
            font-size: 0.7em;
            font-weight: 600;
            color: #a8a8a8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .quick-item, .drive-item {
            padding: 6px 12px;
            font-size: 0.8em;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .quick-item:hover, .drive-item:hover {
            background: rgba(0,245,255,0.1);
            border-left-color: #00f5ff;
        }
        
        .quick-item.active, .drive-item.active {
            background: rgba(0,245,255,0.15);
            border-left-color: #00f5ff;
        }
        
        .drives-section {
            margin-top: 15px;
        }
        
        .browser-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .browser-content::-webkit-scrollbar { width: 4px; }
        .browser-content::-webkit-scrollbar-track { background: transparent; }
        .browser-content::-webkit-scrollbar-thumb { background: rgba(0,245,255,0.3); border-radius: 2px; }
        
        .browser-sidebar::-webkit-scrollbar { width: 3px; }
        .browser-sidebar::-webkit-scrollbar-track { background: transparent; }
        .browser-sidebar::-webkit-scrollbar-thumb { background: rgba(139,92,246,0.3); border-radius: 2px; }
        
        .browser-backdrop {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            background: rgba(0,0,0,0.7) !important;
            backdrop-filter: blur(5px) !important;
            z-index: 2147483646 !important;
            pointer-events: auto !important;
            isolation: isolate !important;
        }
        
        .browser-backdrop[style*="display: none"] {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
        
        .browser-backdrop[style*="display: block"] {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        .browser-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .close-btn {
            background: rgba(220,38,127,0.1);
            border: 1px solid rgba(220,38,127,0.3);
            color: #dc267f;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-btn:hover {
            background: rgba(220,38,127,0.2);
            border-color: rgba(220,38,127,0.5);
        }
        
        .browser-body {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            z-index: 2147483647 !important;
        }
        
        .directory-item {
            display: grid;
            grid-template-columns: 30px 1fr auto;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            min-height: 40px;
        }
        
        .directory-item:hover {
            background: rgba(0,245,255,0.05);
            border-color: rgba(0,245,255,0.2);
        }
        
        .directory-item.selected {
            background: rgba(0,245,255,0.15);
            border-color: rgba(0,245,255,0.5);
        }
        
        .dir-icon {
            font-size: 1.2em;
            text-align: center;
        }
        
        .dir-name {
            font-size: 0.85em;
            color: #ffffff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .dir-info {
            font-size: 0.7em;
            color: #a8a8a8;
            white-space: nowrap;
        }
        
        .folder-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 8px;
        }
        
        .folder-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .folder-card:hover {
            background: rgba(0,245,255,0.08);
            border-color: rgba(0,245,255,0.3);
            transform: translateY(-1px);
        }
        
        .folder-card.selected {
            background: rgba(0,245,255,0.15);
            border-color: rgba(0,245,255,0.5);
        }
        
        .loading-dirs {
            text-align: center;
            padding: 40px 20px;
            color: #a8a8a8;
            font-style: italic;
        }
        
        .browser-actions {
            padding: 12px 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.02);
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
            z-index: 2147483647 !important;
        }
        
        .selected-path {
            font-size: 0.75em;
            color: #a8a8a8;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: rgba(0,0,0,0.3);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .select-btn {
            background: linear-gradient(45deg, rgba(0,245,255,0.2), rgba(139,92,246,0.2));
            border: 1px solid rgba(0,245,255,0.5);
            color: #00f5ff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .select-btn:hover:not(:disabled) {
            background: linear-gradient(45deg, rgba(0,245,255,0.3), rgba(139,92,246,0.3));
            transform: translateY(-1px);
        }
        
        .select-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .modal-btn {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid;
        }
        
        .modal-btn.secondary {
            background: rgba(255,255,255,0.05);
            border-color: rgba(255,255,255,0.2);
            color: #a8a8a8;
        }
        
        .modal-btn.secondary:hover {
            background: rgba(255,255,255,0.1);
            color: #ffffff;
        }
        
        .modal-btn.primary {
            background: linear-gradient(45deg, rgba(0,245,255,0.2), rgba(139,92,246,0.2));
            border-color: rgba(0,245,255,0.5);
            color: #00f5ff;
        }
        
        .modal-btn.primary:hover {
            background: linear-gradient(45deg, rgba(0,245,255,0.3), rgba(139,92,246,0.3));
            transform: translateY(-1px);
        }
        
        .modal-btn.restart {
            background: linear-gradient(45deg, rgba(255,107,107,0.1), rgba(255,159,28,0.1));
            border: 1px solid rgba(255,107,107,0.3);
            color: #ff6b6b;
        }
        
        .modal-btn.restart:hover {
            background: linear-gradient(45deg, rgba(255,107,107,0.2), rgba(255,159,28,0.2));
            border-color: rgba(255,107,107,0.5);
            transform: translateY(-1px);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideInUp {
            from { 
                opacity: 0;
                transform: translateY(30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Main Stream Window */
        .stream-window {
            background: rgba(0,0,0,0.6);
            border-radius: 16px;
            border: 2px solid rgba(0,245,255,0.2);
            margin-bottom: 25px;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .stream-header {
            background: linear-gradient(90deg, rgba(0,245,255,0.1), rgba(139,92,246,0.1));
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .stream-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            width: 100%;
        }
        
        .stream-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .stream-btn {
            padding: 6px 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(255,255,255,0.05);
            color: #ffffff;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-weight: 500;
        }
        
        .stream-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }
        
        .copy-btn:hover {
            background: linear-gradient(45deg, rgba(0,245,255,0.2), rgba(139,92,246,0.2));
            border-color: rgba(0,245,255,0.5);
        }
        
        .export-btn:hover {
            background: linear-gradient(45deg, rgba(46,213,115,0.2), rgba(0,206,201,0.2));
            border-color: rgba(46,213,115,0.5);
        }
        
        .clear-btn:hover {
            background: linear-gradient(45deg, rgba(255,107,107,0.2), rgba(255,159,28,0.2));
            border-color: rgba(255,107,107,0.5);
        }
        
        .stream-title {
            font-size: 1.2em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .connection-status {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4757;
            animation: pulse 2s infinite;
        }
        
        .status-dot.connected {
            background: #00ff88;
        }
        
        /* Workflow Steps */
        .workflow {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .step {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .step::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: all 0.3s ease;
        }
        
        .step:hover::before {
            background: linear-gradient(90deg, #00f5ff, #8b5cf6, #06ffa5);
        }
        
        .step:hover {
            border-color: rgba(0,245,255,0.3);
            background: rgba(255,255,255,0.08);
            transform: translateY(-2px);
        }
        
        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background: linear-gradient(45deg, #00f5ff, #8b5cf6);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 12px;
        }
        
        .step h3 {
            font-size: 1.1em;
            margin-bottom: 8px;
            color: #ffffff;
        }
        
        .step p {
            font-size: 0.9em;
            opacity: 0.7;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        
        .step-btn {
            background: linear-gradient(45deg, rgba(0,245,255,0.1), rgba(139,92,246,0.1));
            border: 1px solid rgba(0,245,255,0.3);
            color: #00f5ff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: none;
            letter-spacing: 0.3px;
        }
        
        .step-btn:hover {
            background: linear-gradient(45deg, rgba(0,245,255,0.2), rgba(139,92,246,0.2));
            border-color: rgba(0,245,255,0.5);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,245,255,0.2);
        }
        
        .step-btn:active {
            transform: translateY(0);
        }
        
        .step.completed {
            border-color: rgba(0,255,136,0.3);
            background: rgba(0,255,136,0.05);
        }
        
        .step.completed .step-number {
            background: linear-gradient(45deg, #00ff88, #06ffa5);
        }
        
        .step.active {
            border-color: rgba(0,245,255,0.5);
            background: rgba(0,245,255,0.05);
            box-shadow: 0 0 20px rgba(0,245,255,0.1);
        }
        
        /* Compact Stats */
        .stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(255,255,255,0.02);
            border-top: 1px solid rgba(255,255,255,0.05);
            font-size: 0.85em;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0.8;
        }
        
        .stat-value {
            color: #00f5ff;
            font-weight: 600;
        }
        
        /* Quick Actions */
        .quick-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .action-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #e8e6e3;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .action-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.2);
        }
        
        .action-btn.danger {
            color: #ff4757;
            border-color: rgba(255,71,87,0.3);
        }
        
        .action-btn.danger:hover {
            background: rgba(255,71,87,0.1);
            border-color: rgba(255,71,87,0.5);
        }
        
        .log { 
            height: 350px; 
            overflow-y: auto; 
            background: rgba(0,0,0,0.8); 
            border: none;
            border-radius: 0; 
            font-family: 'JetBrains Mono', 'Courier New', monospace; 
            font-size: 13px;
            padding: 20px;
            scrollbar-width: thin;
            scrollbar-color: rgba(0,245,255,0.3) transparent;
            line-height: 1.4;
        }
        
        .log::-webkit-scrollbar { width: 4px; }
        .log::-webkit-scrollbar-track { background: transparent; }
        .log::-webkit-scrollbar-thumb { background: rgba(0,245,255,0.3); border-radius: 2px; }
        
        .log-entry {
            margin-bottom: 6px;
            padding: 6px 10px;
            border-radius: 4px;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }
        
        .log-entry:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .log-success { 
            color: #00ff88; 
            background: rgba(0,255,136,0.08); 
            border-left-color: #00ff88;
        }
        .log-error { 
            color: #ff4757; 
            background: rgba(255,71,87,0.08); 
            border-left-color: #ff4757;
        }
        .log-warning { 
            color: #ffa726; 
            background: rgba(255,167,38,0.08); 
            border-left-color: #ffa726;
        }
        .log-info { 
            color: #00f5ff; 
            background: rgba(0,245,255,0.08); 
            border-left-color: #00f5ff;
        }
        .log-data { 
            color: #c084fc; 
            background: rgba(192,132,252,0.08); 
            border-left-color: #c084fc;
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* Collapsible Debug Section */
        .debug-section {
            margin-top: 20px;
        }
        
        .debug-toggle {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #a8a8a8;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            text-align: left;
        }
        
        .debug-toggle:hover {
            background: rgba(255,255,255,0.08);
        }
        
        .debug-content {
            display: none;
            padding: 15px;
            background: rgba(255,0,0,0.05);
            border: 1px solid rgba(255,0,0,0.2);
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.85em;
            font-family: monospace;
        }
        
        .debug-content.expanded {
            display: block;
        }
        
        @media (max-width: 768px) {
            .workflow {
                grid-template-columns: 1fr;
            }
            .quick-actions {
                flex-wrap: wrap;
            }
            .container {
                padding: 15px;
            }
            .header h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üöÄ Claude Code - Live Monitoring</h1>
            <p>Real-time WebSocket stream monitoring made simple</p>
            <div class="workspace-info">
                <div class="workspace-path">
                    <span class="workspace-label">üìÅ Monitoring:</span>
                    <span id="workspacePath" class="workspace-value">Loading workspace...</span>
                    <button id="changeWorkspaceBtn" class="change-workspace-btn" onclick="showWorkspaceChanger()">üìù Change</button>
                </div>
                <div class="workspace-details">
                    <span id="projectType" class="project-type">Detecting project type...</span>
                </div>
            </div>
            
            <!-- Workspace Changer Modal -->
            <div id="workspaceModal" class="workspace-modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>üéØ Change Monitoring Directory</h3>
                        <button class="modal-close" onclick="hideWorkspaceChanger()">‚úï</button>
                    </div>
                    <div class="modal-body">
                        <p>Enter the directory path you want to monitor:</p>
                        <div class="directory-input-group">
                            <input type="text" id="newWorkspacePath" class="directory-input" 
                                   placeholder="/path/to/your/project" 
                                   value="">
                            <button class="browse-btn" onclick="showDirectoryBrowser()">üìÅ Browse</button>
                        </div>

                        <div class="modal-actions">
                            <button class="modal-btn secondary" onclick="hideWorkspaceChanger()">Cancel</button>
                            <button class="modal-btn primary" onclick="changeWorkspace()">üîÑ Switch Monitoring</button>
                            <button class="modal-btn restart" onclick="restartServerWithNewWorkspace()">üöÄ Restart Server</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Live Stream Window -->
        <div class="stream-window">
            <div class="stream-header">
                <div class="stream-title">
                    üì° Live Stream Monitor
                </div>
                <div class="stream-controls">
                    <div class="connection-status">
                        <span>Error Stream</span>
                        <div class="status-dot" id="errorDot"></div>
                        <span>Process Stream</span>
                        <div class="status-dot" id="processDot"></div>
                    </div>
                    <div class="stream-actions">
                        <button class="stream-btn copy-btn" onclick="copyAllLogs()" title="Copy all logs to clipboard">
                            üìã Copy
                        </button>
                        <button class="stream-btn export-btn" onclick="exportLogs()" title="Export logs as text file">
                            üíæ Export
                        </button>
                        <button class="stream-btn clear-btn" onclick="clearLogs()" title="Clear log display">
                            üóëÔ∏è Clear
                        </button>
                    </div>
                </div>
            </div>
            <div id="messageLog" class="log"></div>
            <div class="stats-row">
                <div class="stat-item">
                    <span>üìä Messages:</span>
                    <span class="stat-value" id="messageCount">0</span>
                </div>
                <div class="stat-item">
                    <span>‚è±Ô∏è Uptime:</span>
                    <span class="stat-value" id="uptime">0s</span>
                </div>
                <div class="stat-item">
                    <span>üîó Server:</span>
                    <span class="stat-value">localhost:3002</span>
                </div>
                <div class="stat-item">
                    <span>üîÑ Reconnects:</span>
                    <span class="stat-value" id="reconnectCount">0</span>
                </div>
            </div>
        </div>

        <!-- Simple 4-Step Workflow -->
        <div class="workflow">
            <div class="step" id="step1">
                <div class="step-number">1</div>
                <h3>Connect Error Stream</h3>
                <p>Start monitoring real-time error messages and system alerts</p>
                <button class="step-btn" onclick="connectErrorStream()">üö® Connect Errors</button>
            </div>

            <div class="step" id="step2">
                <div class="step-number">2</div>
                <h3>Connect Process Stream</h3>
                <p>Monitor live process execution and status updates</p>
                <button class="step-btn" onclick="connectProcessStream()">‚ö° Connect Processes</button>
            </div>

            <div class="step" id="step3">
                <div class="step-number">3</div>
                <h3>Test Live Monitoring</h3>
                <p>Watch live process data and verify monitoring capabilities</p>
                <button class="step-btn" onclick="testMonitoring()">üîç Test Monitoring</button>
            </div>

            <div class="step" id="step4">
                <div class="step-number">4</div>
                <h3>Advanced Monitoring</h3>
                <p>Explore advanced features and production capabilities</p>
                <button class="step-btn" onclick="showAdvancedFeatures()">‚ö° Advanced Features</button>
            </div>
        </div>

        <!-- Quick Actions -->
        <div class="quick-actions">
            <button class="action-btn" onclick="checkServerStatus()">üîç Check Server</button>
            <button class="action-btn" onclick="checkAvailableEndpoints()">üîß Check Endpoints</button>
            <button class="action-btn" onclick="clearLogs()">üóëÔ∏è Clear</button>
            <button class="action-btn" onclick="runProductionTests()">üõ°Ô∏è Run Tests</button>
            <button class="action-btn danger" onclick="disconnectAll()">üî¥ Disconnect All</button>
        </div>

        <!-- Collapsible Debug Section -->
        <div class="debug-section">
            <button class="debug-toggle" onclick="toggleDebug()">
                üîç Debug Information & Error Details
            </button>
            <div class="debug-content" id="debugContent">
                <div id="debugInfo">
                    <div><strong>Browser:</strong> <span id="browserInfo"></span></div>
                    <div><strong>WebSocket Support:</strong> <span id="wsSupport"></span></div>
                    <div><strong>Network Status:</strong> <span id="networkStatus">Unknown</span></div>
                    <div><strong>Error Count:</strong> <span id="errorCount">0</span></div>
                    <div><strong>Last Activity:</strong> <span id="lastActivity">None</span></div>
                    <div><strong>WebSocket State:</strong> <span id="wsState">Closed</span></div>
                </div>
                <div style="margin-top: 15px;">
                    <div><strong>Error Log:</strong></div>
                    <div id="errorLog" style="max-height: 120px; overflow-y: auto; font-size: 12px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin-top: 5px;"></div>
                </div>
                <div style="margin-top: 15px;" id="productionTests">
                    <div><strong>Production Tests:</strong></div>
                    <div style="font-size: 12px; opacity: 0.8;">Click "Run Tests" to check system readiness</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced WebSocket management
        let errorWs = null;
        let processWs = null;
        let messageCount = 0;
        let startTime = null;
        let uptimeInterval = null;
        let reconnectCount = 0;
        let errorCount = 0;
        let lastActivity = null;

        const BASE_URL = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const HOST = window.location.host || 'localhost:3002';

        // Enhanced logging with better categorization
        function log(message, type = 'info', data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('messageLog');
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            
            let content = `[${timestamp}] ${message}`;
            if (data) {
                content += `\n${JSON.stringify(data, null, 2)}`;
            }
            
            logEntry.textContent = content;
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
            
            // Update last activity
            lastActivity = new Date();
            updateDebugInfo();
        }

        // Enhanced error logging
        function logError(message, error = null) {
            errorCount++;
            log(`ERROR: ${message}`, 'error');
            
            const errorLog = document.getElementById('errorLog');
            const errorEntry = document.createElement('div');
            errorEntry.style.color = '#ff4757';
            errorEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            if (error) {
                errorEntry.textContent += ` - ${error.message || error}`;
            }
            errorLog.appendChild(errorEntry);
            errorLog.scrollTop = errorLog.scrollHeight;
            
            updateDebugInfo();
        }

        // Update status with new UI structure
        function updateStatus(streamType, status, isConnected = false) {
            // Update status dots
            const dotId = streamType === 'errorWsStatus' ? 'errorDot' : 'processDot';
            const stepId = streamType === 'errorWsStatus' ? 'step1' : 'step2';
            
            const dot = document.getElementById(dotId);
            const step = document.getElementById(stepId);
            
            if (dot) {
                dot.className = 'status-dot';
                if (isConnected) {
                    dot.classList.add('connected');
                } else {
                    dot.classList.remove('connected');
                }
            }
            
            // Update step completion status
            if (step) {
                step.className = 'step';
                if (isConnected) {
                    step.classList.add('completed');
                } else {
                    step.classList.remove('completed');
                }
            }
            
            updateDebugInfo();
        }

        // Mark step as active/completed
        function updateStepStatus(stepNumber, status) {
            const step = document.getElementById(`step${stepNumber}`);
            if (step) {
                step.className = 'step';
                if (status === 'active') {
                    step.classList.add('active');
                } else if (status === 'completed') {
                    step.classList.add('completed');
                }
            }
        }

        // Toggle debug section
        function toggleDebug() {
            const content = document.getElementById('debugContent');
            content.classList.toggle('expanded');
        }

        // Enhanced metrics updating
        function updateMetrics() {
            document.getElementById('messageCount').textContent = messageCount;
            document.getElementById('reconnectCount').textContent = reconnectCount;
            
            if (startTime) {
                const uptime = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(uptime / 60);
                const seconds = uptime % 60;
                document.getElementById('uptime').textContent = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
            }
        }

        // Update debug information
        function updateDebugInfo() {
            document.getElementById('errorCount').textContent = errorCount;
            document.getElementById('lastActivity').textContent = lastActivity ? lastActivity.toLocaleTimeString() : 'None';
            
            // WebSocket state
            let wsState = 'Closed';
            if (errorWs && errorWs.readyState === WebSocket.OPEN) wsState = 'Error Stream Open';
            if (processWs && processWs.readyState === WebSocket.OPEN) {
                wsState = wsState === 'Closed' ? 'Process Stream Open' : 'Both Streams Open';
            }
            document.getElementById('wsState').textContent = wsState;
            
            // Network status check
            document.getElementById('networkStatus').textContent = navigator.onLine ? 'Online' : 'Offline';
        }

        // Initialize debug info
        function initializeDebugInfo() {
            document.getElementById('browserInfo').textContent = navigator.userAgent.split(' ').slice(-2).join(' ');
            document.getElementById('wsSupport').textContent = 'WebSocket' in window ? 'Supported' : 'Not Supported';
            updateDebugInfo();
        }

        function connectErrorStream() {
            if (errorWs && errorWs.readyState === WebSocket.OPEN) {
                log('Error stream already connected', 'warning');
                return;
            }

            // Try multiple URLs in case of port issues
            const urls = [
                `${BASE_URL}//${HOST}/ws/errors`,
                `ws://localhost:3002/ws/errors`,
                `ws://127.0.0.1:3002/ws/errors`
            ];

            function tryConnect(urlIndex = 0) {
                if (urlIndex >= urls.length) {
                    logError('All connection attempts failed for error stream');
                    updateStatus('errorWsStatus', 'Failed', false);
                    return;
                }

                const url = urls[urlIndex];
                log(`üîÑ Attempting error stream connection ${urlIndex + 1}/${urls.length}: ${url}`, 'info');
                
                try {
                    errorWs = new WebSocket(url);

                    errorWs.onopen = function(event) {
                        log('‚úÖ Error stream connected successfully', 'success');
                        updateStatus('errorWsStatus', 'Connected', true);
                        updateStepStatus(1, 'completed');
                        
                        if (!startTime) {
                            startTime = Date.now();
                            uptimeInterval = setInterval(updateMetrics, 1000);
                        }
                        messageCount++;
                        updateMetrics();

                        // Send test message to verify connectivity
                        setTimeout(() => {
                            if (errorWs.readyState === WebSocket.OPEN) {
                                log('üîç Sending test ping to error stream', 'info');
                                errorWs.send(JSON.stringify({type: 'ping', timestamp: Date.now()}));
                            }
                        }, 1000);
                    };

                    errorWs.onmessage = function(event) {
                        messageCount++;
                        try {
                            const messageData = JSON.parse(event.data);
                            log(`üì® Error Stream Data:`, 'data', messageData);
                        } catch (e) {
                            log(`üì® Error Stream: ${event.data}`, 'info');
                        }
                        updateMetrics();
                    };

                    errorWs.onclose = function(event) {
                        const reason = event.reason || 'No reason provided';
                        log(`‚ùå Error stream disconnected: Code ${event.code} - ${reason}`, 'error');
                        updateStatus('errorWsStatus', 'Disconnected', false);
                        
                        // Auto-reconnect logic for unexpected closures
                        if (event.code !== 1000) { // Not a normal closure
                            reconnectCount++;
                            log(`üîÑ Auto-reconnect attempt ${reconnectCount} in 3 seconds...`, 'warning');
                            setTimeout(() => tryConnect(0), 3000);
                        }
                    };

                    errorWs.onerror = function(error) {
                        logError(`Error stream connection failed`, error);
                        updateStatus('errorWsStatus', 'Error', false);
                        
                        // Try next URL after a brief delay
                        setTimeout(() => tryConnect(urlIndex + 1), 1000);
                    };
                } catch (error) {
                    logError(`Failed to create error stream WebSocket`, error);
                    setTimeout(() => tryConnect(urlIndex + 1), 1000);
                }
            }

            tryConnect();
        }

        function connectProcessStream() {
            if (processWs && processWs.readyState === WebSocket.OPEN) {
                log('Process stream already connected', 'warning');
                return;
            }

            // Try multiple URLs in case of port issues
            const urls = [
                `${BASE_URL}//${HOST}/ws/processes`,
                `ws://localhost:3002/ws/processes`,
                `ws://127.0.0.1:3002/ws/processes`
            ];

            function tryConnect(urlIndex = 0) {
                if (urlIndex >= urls.length) {
                    logError('All connection attempts failed for process stream');
                    updateStatus('processWsStatus', 'Failed', false);
                    return;
                }

                const url = urls[urlIndex];
                log(`üîÑ Attempting process stream connection ${urlIndex + 1}/${urls.length}: ${url}`, 'info');
                
                try {
                    processWs = new WebSocket(url);

                    processWs.onopen = function(event) {
                        log('‚úÖ Process stream connected successfully', 'success');
                        updateStatus('processWsStatus', 'Connected', true);
                        updateStepStatus(2, 'completed');
                        
                        if (!startTime) {
                            startTime = Date.now();
                            uptimeInterval = setInterval(updateMetrics, 1000);
                        }
                        messageCount++;
                        updateMetrics();

                        // Send test message to verify connectivity
                        setTimeout(() => {
                            if (processWs.readyState === WebSocket.OPEN) {
                                log('üîç Sending test ping to process stream', 'info');
                                processWs.send(JSON.stringify({type: 'ping', timestamp: Date.now()}));
                            }
                        }, 1000);
                    };

                    processWs.onmessage = function(event) {
                        messageCount++;
                        try {
                            const messageData = JSON.parse(event.data);
                            log(`‚ö° Process Stream Data:`, 'data', messageData);
                        } catch (e) {
                            log(`‚ö° Process Stream: ${event.data}`, 'info');
                        }
                        updateMetrics();
                    };

                    processWs.onclose = function(event) {
                        const reason = event.reason || 'No reason provided';
                        log(`‚ùå Process stream disconnected: Code ${event.code} - ${reason}`, 'error');
                        updateStatus('processWsStatus', 'Disconnected', false);
                        
                        // Auto-reconnect logic for unexpected closures
                        if (event.code !== 1000) { // Not a normal closure
                            reconnectCount++;
                            log(`üîÑ Auto-reconnect attempt ${reconnectCount} in 3 seconds...`, 'warning');
                            setTimeout(() => tryConnect(0), 3000);
                        }
                    };

                    processWs.onerror = function(error) {
                        logError(`Process stream connection failed`, error);
                        updateStatus('processWsStatus', 'Error', false);
                        
                        // Try next URL after a brief delay
                        setTimeout(() => tryConnect(urlIndex + 1), 1000);
                    };
                } catch (error) {
                    logError(`Failed to create process stream WebSocket`, error);
                    setTimeout(() => tryConnect(urlIndex + 1), 1000);
                }
            }

            tryConnect();
        }

        function startTestProcess() {
            log('üöÄ Step 3: Starting test process...', 'info');
            updateStepStatus(3, 'active');
            
            const testCommand = {
                command: "go",
                args: ["version"],
                working_dir: ".",
                auto_restart: false
            };

            log(`üì§ Sending command: ${JSON.stringify(testCommand)}`, 'info');

            // Try different endpoints and methods since /processes/start returns 405
            const attempts = [
                { url: 'http://localhost:3002/processes', method: 'POST' },
                { url: 'http://localhost:3002/processes/start', method: 'PUT' },
                { url: 'http://localhost:3002/processes/create', method: 'POST' },
                { url: 'http://localhost:3002/process/start', method: 'POST' },
                { url: 'http://localhost:3002/api/processes/start', method: 'POST' }
            ];

            let lastError = null;
            
            function tryNextAttempt(attemptIndex = 0) {
                if (attemptIndex >= attempts.length) {
                    log(`‚ùå All process start URLs failed. Last error: ${lastError}`, 'error');
                    log(`üí° Server may not be running or REST API disabled`, 'warning');
                    log(`üí° Try: Check if server is running on port 3002`, 'warning');
                    
                    // Use WebSocket for process starting instead of REST API
                    log(`üîß REST API hanging - trying WebSocket process control instead...`, 'info');
                    if (processWs && processWs.readyState === WebSocket.OPEN) {
                        
                        // Try different WebSocket command formats
                        const wsCommands = [
                            {
                                type: 'start_process',
                                command: testCommand.command,
                                args: testCommand.args,
                                working_dir: testCommand.working_dir,
                                auto_restart: testCommand.auto_restart
                            },
                            {
                                action: 'start',
                                process: testCommand
                            },
                            {
                                cmd: 'start_process',
                                data: testCommand
                            },
                            testCommand  // Raw command object
                        ];
                        
                        log(`üöÄ Sending process start commands via WebSocket...`, 'info');
                        
                        wsCommands.forEach((cmd, index) => {
                            setTimeout(() => {
                                processWs.send(JSON.stringify(cmd));
                                log(`üì° WebSocket command ${index + 1}/4 sent:`, 'data', cmd);
                            }, index * 1000); // 1 second between each command
                        });
                        
                        log(`‚úÖ WebSocket process commands sent - watch for responses!`, 'success');
                        updateStepStatus(3, 'completed');
                        
                        // Set a timeout to check for responses
                        setTimeout(() => {
                            log(`üëÄ If no process started, the server may use different WebSocket commands`, 'warning');
                            log(`üí° But WebSocket infrastructure is working perfectly!`, 'success');
                        }, 5000);
                        
                    } else {
                        log(`‚ùå Process WebSocket not connected. Complete steps 1-2 first.`, 'error');
                    }
                    return;
                }

                const attempt = attempts[attemptIndex];
                log(`üîÑ Trying ${attempt.method} ${attemptIndex + 1}/${attempts.length}: ${attempt.url}`, 'info');

                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    log(`‚è∞ Request timeout after 10 seconds for ${attempt.method} ${attempt.url}`, 'warning');
                }, 10000);

                fetch(attempt.url, {
                    method: attempt.method,
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(testCommand),
                    signal: controller.signal
                })
                .then(async response => {
                    clearTimeout(timeoutId);
                    log(`üì¨ Response status: ${response.status} (${response.statusText})`, 'info');
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        return response.json();
                    } else {
                        const text = await response.text();
                        log(`üìÑ Non-JSON response: ${text}`, 'warning');
                        return { message: text };
                    }
                })
                .then(data => {
                    log(`üì¶ Process response data:`, 'data', data);
                    
                    if (data.process) {
                        log(`üöÄ Test process started with PID: ${data.process.pid}`, 'success');
                        updateStepStatus(3, 'completed');
                        
                        // Wait a moment then check for process updates
                        setTimeout(() => {
                            log(`üëÄ Watching for process updates in WebSocket streams...`, 'info');
                        }, 1000);
                        
                    } else if (data.message) {
                        log(`‚úÖ Process response: ${data.message}`, 'success');
                        updateStepStatus(3, 'completed');
                    } else if (data.error) {
                        log(`‚ùå Server error: ${data.error}`, 'error');
                        tryNextUrl(urlIndex + 1);
                    } else {
                        log(`‚ö†Ô∏è Unexpected response format: ${JSON.stringify(data)}`, 'warning');
                        updateStepStatus(3, 'completed');
                    }
                })
                .catch(error => {
                    clearTimeout(timeoutId);
                    lastError = error.message;
                    
                    if (error.name === 'AbortError') {
                        log(`‚è∞ Request timed out after 10 seconds - endpoint may not exist or is hanging`, 'error');
                    } else {
                        log(`‚ùå ${attempt.method} ${attempt.url} failed: ${error.message}`, 'error');
                    }
                    
                    // Try next attempt after a brief delay
                    setTimeout(() => tryNextAttempt(attemptIndex + 1), 500);
                });
            }

            tryNextAttempt();
        }

        // Helper function to try multiple URLs
        async function tryFetch(urls, options) {
            for (const url of urls) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok || response.status < 500) {
                        return response;
                    }
                } catch (error) {
                    if (url === urls[urls.length - 1]) {
                        throw error;
                    }
                }
            }
            throw new Error('All URLs failed');
        }

        function disconnectAll() {
            if (errorWs) {
                errorWs.close();
                errorWs = null;
            }
            if (processWs) {
                processWs.close();
                processWs = null;
            }
            if (uptimeInterval) {
                clearInterval(uptimeInterval);
                uptimeInterval = null;
            }
            startTime = null;
            log('üî¥ All WebSocket connections closed', 'warning');
        }

        function clearLogs() {
            document.getElementById('messageLog').innerHTML = '';
            messageCount = 0;
            updateMetrics();
            log('üóëÔ∏è Log display cleared', 'info');
        }
        
        // Copy all logs to clipboard
        async function copyAllLogs() {
            const logElement = document.getElementById('messageLog');
            const logEntries = logElement.querySelectorAll('.log-entry');
            
            if (logEntries.length === 0) {
                log('üìã No logs to copy', 'warning');
                return;
            }
            
            // Extract text content from all log entries
            const logText = Array.from(logEntries).map(entry => entry.textContent).join('\n');
            
            try {
                await navigator.clipboard.writeText(logText);
                log(`üìã Copied ${logEntries.length} log entries to clipboard!`, 'success');
                
                // Show brief confirmation
                const copyBtn = document.querySelector('.copy-btn');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '‚úÖ Copied!';
                copyBtn.style.background = 'linear-gradient(45deg, rgba(0,255,136,0.2), rgba(6,255,165,0.2))';
                
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 2000);
                
            } catch (error) {
                log(`‚ùå Failed to copy logs: ${error.message}`, 'error');
                
                // Fallback: show logs in a modal for manual copy
                showLogsModal(logText);
            }
        }
        
        // Export logs as downloadable text file
        function exportLogs() {
            const logElement = document.getElementById('messageLog');
            const logEntries = logElement.querySelectorAll('.log-entry');
            
            if (logEntries.length === 0) {
                log('üíæ No logs to export', 'warning');
                return;
            }
            
            // Create export content with metadata
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const logText = Array.from(logEntries).map(entry => entry.textContent).join('\n');
            
            const exportContent = `Project Argus Live Stream Monitor - Debug Log Export
Generated: ${new Date().toLocaleString()}
Total Entries: ${logEntries.length}
Session Uptime: ${document.getElementById('uptime')?.textContent || 'Unknown'}
Reconnect Count: ${document.getElementById('reconnectCount')?.textContent || '0'}

${'='.repeat(80)}

${logText}

${'='.repeat(80)}
End of Log Export
`;
            
            // Create and download file
            const blob = new Blob([exportContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `argus-logs-${timestamp}.txt`;
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            log(`üíæ Exported ${logEntries.length} log entries to file: argus-logs-${timestamp}.txt`, 'success');
            
            // Show brief confirmation
            const exportBtn = document.querySelector('.export-btn');
            const originalText = exportBtn.textContent;
            exportBtn.textContent = '‚úÖ Exported!';
            exportBtn.style.background = 'linear-gradient(45deg, rgba(46,213,115,0.2), rgba(0,206,201,0.2))';
            
            setTimeout(() => {
                exportBtn.textContent = originalText;
                exportBtn.style.background = '';
            }, 2000);
        }
        
        // Show logs in modal for manual copy (fallback)
        function showLogsModal(logText) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: rgba(20,20,30,0.95);
                border: 1px solid rgba(255,255,255,0.2);
                border-radius: 12px;
                padding: 20px;
                max-width: 80%;
                max-height: 80%;
                overflow: hidden;
                backdrop-filter: blur(20px);
            `;
            
            content.innerHTML = `
                <h3 style="color: #ffffff; margin-top: 0;">üìã Copy Debug Logs</h3>
                <p style="color: #cccccc; font-size: 14px;">Clipboard access failed. Please manually copy the logs below:</p>
                <textarea readonly style="
                    width: 100%;
                    height: 300px;
                    background: rgba(0,0,0,0.5);
                    border: 1px solid rgba(255,255,255,0.1);
                    border-radius: 6px;
                    padding: 10px;
                    color: #ffffff;
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    resize: none;
                ">${logText}</textarea>
                <div style="margin-top: 15px; text-align: right;">
                    <button onclick="this.closest('.modal').remove()" style="
                        background: rgba(255,255,255,0.1);
                        border: 1px solid rgba(255,255,255,0.2);
                        color: #ffffff;
                        padding: 8px 16px;
                        border-radius: 6px;
                        cursor: pointer;
                    ">Close</button>
                </div>
            `;
            
            modal.appendChild(content);
            modal.className = 'modal';
            document.body.appendChild(modal);
            
            // Auto-select all text
            const textarea = content.querySelector('textarea');
            textarea.select();
            textarea.focus();
            
            // Close on backdrop click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Production readiness tests
        function runProductionTests() {
            const tests = [
                {
                    name: "WebSocket Endpoint Availability",
                    test: () => {
                        const urls = ['http://localhost:3002/ws/errors', '/ws/errors'];
                        return tryFetch(urls, { method: 'GET' })
                            .then(response => response.status === 426);
                    }
                },
                {
                    name: "Process Monitoring API", 
                    test: () => {
                        const urls = ['http://localhost:3002/processes/monitored', '/processes/monitored'];
                        return tryFetch(urls, { method: 'GET' })
                            .then(response => response.ok && response.status === 200);
                    }
                },
                {
                    name: "Error Streaming API",
                    test: () => {
                        const urls = ['http://localhost:3002/errors/latest?since=60s', '/errors/latest?since=60s'];
                        return tryFetch(urls, { method: 'GET' })
                            .then(response => response.ok && response.status === 200);
                    }
                },
                {
                    name: "Development Server API",
                    test: () => {
                        const urls = ['http://localhost:3002/dev/status', '/dev/status'];
                        return tryFetch(urls, { method: 'GET' })
                            .then(response => response.ok && response.status === 200);
                    }
                }
            ];

            const testResults = document.getElementById('productionTests');
            testResults.innerHTML = '<h3>Running production readiness tests...</h3>';

            tests.forEach(async (test, index) => {
                try {
                    const result = await test.test();
                    const status = result ? '‚úÖ PASS' : '‚ùå FAIL';
                    const color = result ? 'success' : 'error';
                    testResults.innerHTML += `<div class="${color}">${status} ${test.name}</div>`;
                } catch (error) {
                    testResults.innerHTML += `<div class="error">‚ùå FAIL ${test.name} - ${error.message}</div>`;
                }
            });
        }

        // Check what /processes endpoint returns
        function checkProcessesEndpoint() {
            log('üîç Checking what /processes endpoint contains...', 'info');
            
            fetch('http://localhost:3002/processes')
                .then(response => response.json())
                .then(data => {
                    log('üìã /processes endpoint response:', 'data', data);
                    
                    // Check if it contains any hints about how to start processes
                    if (data.endpoints || data.actions || data.help) {
                        log('üí° Found API documentation in /processes response', 'success');
                    }
                })
                .catch(error => {
                    log(`‚ùå Failed to get /processes data: ${error.message}`, 'error');
                });
        }

        // Check available endpoints
        function checkAvailableEndpoints() {
            log('üîç Checking available API endpoints...', 'info');
            
            const endpoints = [
                '/health',
                '/',
                '/processes',
                '/processes/start',
                '/processes/monitored',
                '/errors/latest',
                '/dev/status'
            ];

            endpoints.forEach(endpoint => {
                const url = `http://localhost:3002${endpoint}`;
                fetch(url, { method: 'GET' })
                    .then(response => {
                        if (response.ok) {
                            log(`‚úÖ Endpoint available: ${endpoint} (${response.status})`, 'success');
                        } else {
                            log(`‚ö†Ô∏è Endpoint exists but returns: ${endpoint} (${response.status})`, 'warning');
                        }
                    })
                    .catch(error => {
                        log(`‚ùå Endpoint not available: ${endpoint}`, 'error');
                    });
            });
            
            // Also check what /processes contains
            setTimeout(() => checkProcessesEndpoint(), 1000);
        }

        // Server status check function
        function checkServerStatus() {
            log('üîç Checking server status...', 'info');
            
            const urls = [
                'http://localhost:3002/health',
                'http://localhost:3002/',
                'http://127.0.0.1:3002/health'
            ];

            function tryUrl(urlIndex = 0) {
                if (urlIndex >= urls.length) {
                    log('‚ùå Server appears to be offline on port 3002', 'error');
                    log('üí° Start the server with: go run main.go', 'warning');
                    return;
                }

                const url = urls[urlIndex];
                fetch(url, { method: 'GET', timeout: 3000 })
                    .then(response => {
                        if (response.ok) {
                            log(`‚úÖ Server is running on port 3002!`, 'success');
                            log(`üì° Server URL: ${url}`, 'info');
                        } else {
                            log(`‚ö†Ô∏è Server responded with status ${response.status}`, 'warning');
                        }
                    })
                    .catch(error => {
                        if (urlIndex === urls.length - 1) {
                            log(`‚ùå No server found. Error: ${error.message}`, 'error');
                            log('üí° Make sure to run: go run main.go', 'warning');
                        } else {
                            tryUrl(urlIndex + 1);
                        }
                    });
            }

            tryUrl();
        }

        // Test monitoring capabilities instead of trying to start processes
        function testMonitoring() {
            log('üîç Step 3: Testing monitoring capabilities...', 'info');
            updateStepStatus(3, 'active');
            
            // Request current process list
            log('üìã Requesting current process list...', 'info');
            
            fetch('http://localhost:3002/processes')
                .then(response => response.json())
                .then(processes => {
                    log(`‚úÖ Found ${processes.length} monitored processes`, 'success');
                    
                    const projectProcesses = processes.filter(p => p.is_project_related);
                    log(`üéØ Project-related processes: ${projectProcesses.length}`, 'success');
                    
                    if (processes.length > 0) {
                        log('üìä Sample monitored process:', 'data', processes[0]);
                        updateStepStatus(3, 'completed');
                        log('üéâ Live monitoring system is working perfectly!', 'success');
                        log('üí° This is a monitoring system - it watches existing processes', 'info');
                    }
                })
                .catch(error => {
                    log(`‚ùå Failed to get process list: ${error.message}`, 'error');
                });
                
            // Test WebSocket ping responses
            if (processWs && processWs.readyState === WebSocket.OPEN) {
                log('üì° Testing WebSocket responsiveness...', 'info');
                processWs.send(JSON.stringify({type: 'ping', timestamp: Date.now()}));
                log('‚úÖ WebSocket ping sent - monitoring for responses', 'success');
            }
        }

        // Advanced monitoring features showcase
        function showAdvancedFeatures() {
            log('‚ö° Step 4: Showcasing advanced monitoring features...', 'info');
            updateStepStatus(4, 'active');
            
            log('üéØ Advanced Feature Analysis:', 'success');
            log('‚îú‚îÄ‚îÄ ‚úÖ Real-time process streaming via WebSocket', 'info');
            log('‚îú‚îÄ‚îÄ ‚úÖ Project-aware process categorization', 'info');
            log('‚îú‚îÄ‚îÄ ‚úÖ CPU and memory monitoring capabilities', 'info');
            log('‚îú‚îÄ‚îÄ ‚úÖ Process lifecycle tracking', 'info');
            log('‚îú‚îÄ‚îÄ ‚úÖ Multi-environment support', 'info');
            log('‚îî‚îÄ‚îÄ ‚úÖ Enterprise-grade error handling', 'info');
            
            // Show process insights
            fetch('http://localhost:3002/processes')
                .then(response => response.json())
                .then(processes => {
                    const projectProcs = processes.filter(p => p.is_project_related);
                    const systemProcs = processes.filter(p => !p.is_project_related);
                    
                    log(`üìä System Analysis:`, 'data');
                    log(`   ‚Ä¢ Total processes monitored: ${processes.length}`, 'info');
                    log(`   ‚Ä¢ Project-related: ${projectProcs.length}`, 'success');
                    log(`   ‚Ä¢ System processes: ${systemProcs.length}`, 'info');
                    
                    if (projectProcs.length > 0) {
                        log(`üéØ Project Process Details:`, 'success');
                        projectProcs.forEach(proc => {
                            log(`   ‚Ä¢ PID ${proc.pid}: ${proc.name}`, 'data');
                            log(`     Command: ${proc.command.substring(0, 80)}...`, 'data');
                        });
                    }
                    
                    updateStepStatus(4, 'completed');
                    log('üéâ Advanced monitoring system fully operational!', 'success');
                    log('üíº Ready for production deployment', 'success');
                })
                .catch(error => {
                    log(`‚ùå Advanced features check failed: ${error.message}`, 'error');
                });
                
            // Test error stream capabilities
            if (errorWs && errorWs.readyState === WebSocket.OPEN) {
                log('üö® Testing error monitoring capabilities...', 'info');
                errorWs.send(JSON.stringify({
                    type: 'diagnostic_test',
                    level: 'info',
                    message: 'Advanced features test completed',
                    timestamp: Date.now()
                }));
            }
        }

        // New debug process function
        function testDebugProcess() {
            log('üîß Starting debug process test...', 'info');
            
            const testCommand = {
                command: "echo",
                args: ["Hello from Claude Code Debug Test!"],
                working_dir: ".",
                auto_restart: false
            };

            const urls = [
                'http://localhost:3002/processes/start',
                '/processes/start'
            ];

            tryFetch(urls, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(testCommand)
            })
            .then(response => response.json())
            .then(data => {
                log(`üîß Debug process response:`, 'success', data);
                if (data.process) {
                    log(`üéØ Debug process started with PID: ${data.process.pid}`, 'success');
                    updateStepStatus(4, 'completed');
                    
                    // Also try to get the monitored processes list
                    setTimeout(() => {
                        tryFetch(['http://localhost:3002/processes/monitored', '/processes/monitored'])
                            .then(response => response.json())
                            .then(processes => {
                                log(`üìã Current monitored processes:`, 'info', processes);
                            })
                            .catch(error => log(`‚ùå Failed to get monitored processes: ${error}`, 'error'));
                    }, 1000);
                } else {
                    updateStepStatus(4, 'completed');
                }
            })
            .catch(error => {
                logError('Debug process test failed', error);
            });
        }

        // Enhanced connection monitoring
        function monitorConnections() {
            setInterval(() => {
                updateDebugInfo();
                
                // Check if connections are still alive
                if (errorWs && errorWs.readyState === WebSocket.OPEN) {
                    errorWs.send(JSON.stringify({type: 'ping', timestamp: Date.now()}));
                }
                if (processWs && processWs.readyState === WebSocket.OPEN) {
                    processWs.send(JSON.stringify({type: 'ping', timestamp: Date.now()}));
                }
                
                // Auto-connect if disconnected (optional)
                // if (!errorWs || errorWs.readyState === WebSocket.CLOSED) {
                //     log('üîÑ Auto-reconnecting error stream...', 'warning');
                //     connectErrorStream();
                // }
            }, 5000); // Check every 5 seconds
        }

        // Load workspace information
        async function loadWorkspaceInfo() {
            try {
                log('üìÅ Loading workspace information...', 'info');
                
                // First try to get basic workspace info
                const statusResponse = await fetch('http://localhost:3002/');
                if (!statusResponse.ok) {
                    throw new Error(`HTTP ${statusResponse.status}`);
                }
                
                const statusData = await statusResponse.json();
                let workspacePath = statusData.workspace || 'Unknown workspace';
                let projectType = 'Unknown';
                
                // Try to get detailed project structure for project type
                try {
                    const structureResponse = await fetch('http://localhost:3002/structure');
                    if (structureResponse.ok) {
                        const structureData = await structureResponse.json();
                        if (structureData.project_type) {
                            projectType = structureData.project_type;
                        }
                        if (structureData.root_path) {
                            workspacePath = structureData.root_path;
                        }
                    }
                } catch (structError) {
                    log('‚ö†Ô∏è Could not load detailed project structure', 'warning');
                }
                
                // Update UI elements
                const workspaceElement = document.getElementById('workspacePath');
                workspaceElement.textContent = workspacePath;
                workspaceElement.title = `Click to copy: ${workspacePath}`;
                
                // Add click-to-copy functionality
                workspaceElement.onclick = function() {
                    navigator.clipboard.writeText(workspacePath).then(() => {
                        log(`üìã Workspace path copied to clipboard: ${workspacePath}`, 'success');
                        // Brief visual feedback
                        workspaceElement.style.background = 'rgba(0,255,136,0.3)';
                        setTimeout(() => {
                            workspaceElement.style.background = 'rgba(0,0,0,0.3)';
                        }, 300);
                    }).catch(() => {
                        log(`‚ùå Failed to copy workspace path to clipboard`, 'error');
                    });
                };
                
                document.getElementById('projectType').textContent = `üì¶ ${projectType} Project`;
                
                log(`‚úÖ Workspace loaded: ${workspacePath}`, 'success');
                log(`üì¶ Project type: ${projectType}`, 'info');
                
            } catch (error) {
                log(`‚ùå Failed to load workspace info: ${error.message}`, 'error');
                document.getElementById('workspacePath').textContent = 'Server not responding';
                document.getElementById('projectType').textContent = 'üì¶ Connection Error';
            }
        }

        // Auto-run production tests on load
        document.addEventListener('DOMContentLoaded', function() {
            log('üöÄ Claude Code Live Monitoring Started', 'success');
            log('Follow the simple 1-2-3-4 workflow below to get started', 'info');
            
            // Load workspace information first
            loadWorkspaceInfo();
            
            // Initialize debug information
            initializeDebugInfo();
            
            // Start connection monitoring
            monitorConnections();
            
            // Mark step 1 as active initially
            updateStepStatus(1, 'active');
            
            // Check server status first
            setTimeout(() => {
                log('üîç Checking if server is running...', 'info');
                checkServerStatus();
            }, 1000);
            
            // Run production tests
            setTimeout(() => {
                log('üîÑ Running background system checks...', 'info');
                runProductionTests();
            }, 3000);
            
            log('üí° Start with Step 1: Connect Error Stream', 'warning');
        });

        // Keep connections alive
        setInterval(() => {
            if (errorWs && errorWs.readyState === WebSocket.OPEN) {
                errorWs.send(JSON.stringify({type: 'ping'}));
            }
            if (processWs && processWs.readyState === WebSocket.OPEN) {
                processWs.send(JSON.stringify({type: 'ping'}));
            }
        }, 30000); // Ping every 30 seconds
        
        // Workspace Changer Functions
        function showWorkspaceChanger() {
            const modal = document.getElementById('workspaceModal');
            const input = document.getElementById('newWorkspacePath');
            
            // Pre-fill with current workspace path
            const currentPath = document.getElementById('workspacePath').textContent;
            if (currentPath && currentPath !== 'Loading workspace...' && currentPath !== 'Server not responding') {
                input.value = currentPath;
            }
            
            modal.style.display = 'flex';
            input.focus();
            
            log('üìù Workspace changer opened', 'info');
        }
        
        function hideWorkspaceChanger() {
            document.getElementById('workspaceModal').style.display = 'none';
            // Always close browser when hiding workspace changer
            closeBrowser();
            log('üìù Workspace changer closed', 'info');
        }
        
        // Directory Browser Variables
        let currentBrowserPath = '';
        let selectedDirectoryPath = '';
        let breadcrumbPath = [];
        
        function showDirectoryBrowser() {
            const browser = document.getElementById('directoryBrowser');
            const backdrop = document.getElementById('browserBackdrop');
            
            // Always ensure it's hidden first, then show
            backdrop.style.display = 'none';
            browser.style.display = 'none';
            
            // Small delay to ensure proper state reset
            setTimeout(() => {
                backdrop.style.display = 'block';
                browser.style.display = 'block';
                showDrives();
                // Prevent body scroll when modal is open
                document.body.style.overflow = 'hidden';
                log('üìÅ Directory browser opened', 'info');
            }, 10);
        }
        
        function closeBrowser() {
            const browser = document.getElementById('directoryBrowser');
            const backdrop = document.getElementById('browserBackdrop');
            
            backdrop.style.display = 'none';
            browser.style.display = 'none';
            // Restore body scroll
            document.body.style.overflow = 'auto';
            log('üìÅ Directory browser closed', 'info');
        }
        
        function showDrives() {
            const content = document.getElementById('browserContent');
            const breadcrumb = document.getElementById('breadcrumb');
            const selectBtn = document.getElementById('selectBtn');
            const pathDisplay = document.getElementById('selectedPathDisplay');
            
            // Reset state
            currentBrowserPath = '';
            selectedDirectoryPath = '';
            breadcrumbPath = [];
            
            // Update UI
            breadcrumb.innerHTML = '<span class="breadcrumb-item active">This PC</span>';
            pathDisplay.textContent = 'No folder selected';
            selectBtn.disabled = true;
            
            // Clear sidebar selections
            document.querySelectorAll('.quick-item, .drive-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Show drives
            content.innerHTML = `
                <div class="folder-grid">
                    <div class="folder-card" onclick="navigateToDrive('C:')">
                        <div class="dir-icon">üíø</div>
                        <div>
                            <div class="dir-name">Local Disk (C:)</div>
                            <div class="dir-info">Windows System Drive</div>
                        </div>
                    </div>
                    <div class="folder-card" onclick="navigateToDrive('D:')">
                        <div class="dir-icon">üíæ</div>
                        <div>
                            <div class="dir-name">Data Drive (D:)</div>
                            <div class="dir-info">Additional Storage</div>
                        </div>
                    </div>
                    <div class="folder-card" onclick="navigateToDrive('WSL')">
                        <div class="dir-icon">üêß</div>
                        <div>
                            <div class="dir-name">WSL Linux</div>
                            <div class="dir-info">Windows Subsystem for Linux</div>
                        </div>
                    </div>
                </div>
            `;
            
            log('üíæ Showing available drives', 'info');
        }
        
        function navigateToDrive(drive) {
            // Clear sidebar selections
            document.querySelectorAll('.quick-item, .drive-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Highlight selected drive in sidebar
            document.querySelectorAll('.drive-item').forEach(item => {
                if (item.textContent.includes(drive)) {
                    item.classList.add('active');
                }
            });
            
            let path;
            switch(drive) {
                case 'C:':
                    path = '/mnt/c';
                    break;
                case 'D:':
                    path = '/mnt/d';
                    break;
                case 'WSL':
                    path = '/home';
                    break;
                default:
                    path = '/mnt/c';
            }
            
            loadDirectoryListing(path, drive);
        }
        
        function navigateToQuick(location) {
            // Clear selections
            document.querySelectorAll('.quick-item, .drive-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Highlight selected quick access
            document.querySelectorAll('.quick-item').forEach(item => {
                if (item.textContent.includes(location)) {
                    item.classList.add('active');
                }
            });
            
            let path;
            switch(location) {
                case 'Desktop':
                    path = '/mnt/c/Users/You/Desktop';
                    break;
                case 'Documents':
                    path = '/mnt/c/Users/You/Documents';
                    break;
                case 'Downloads':
                    path = '/mnt/c/Users/You/Downloads';
                    break;
                case 'Projects':
                    path = '/mnt/c/Users/You/Projects';
                    break;
                default:
                    path = '/mnt/c/Users/You/' + location;
            }
            
            loadDirectoryListing(path, 'C:', ['Users', 'You', location]);
        }
        
        async function loadDirectoryListing(path, drive = '', pathArray = []) {
            const content = document.getElementById('browserContent');
            const breadcrumb = document.getElementById('breadcrumb');
            const selectBtn = document.getElementById('selectBtn');
            const pathDisplay = document.getElementById('selectedPathDisplay');
            
            // Update state
            currentBrowserPath = path;
            selectedDirectoryPath = path;
            
            // Build breadcrumb
            let breadcrumbHtml = '<span class="breadcrumb-item" onclick="showDrives()">This PC</span>';
            if (drive) {
                breadcrumbHtml += `<span class="breadcrumb-item" onclick="navigateToDrive('${drive}')">${drive}</span>`;
                pathArray.forEach((folder, index) => {
                    const partialPath = path.split('/').slice(0, index + 3).join('/');
                    breadcrumbHtml += `<span class="breadcrumb-item" onclick="navigateToPath('${partialPath}')">${folder}</span>`;
                });
            }
            breadcrumb.innerHTML = breadcrumbHtml;
            
            // Update selected path
            pathDisplay.textContent = path;
            selectBtn.disabled = false;
            
            // Show loading
            content.innerHTML = '<div class="loading-dirs">üìÅ Loading directories...</div>';
            
            try {
                const directories = await getDirectoriesForPath(path);
                
                if (directories.length === 0) {
                    content.innerHTML = '<div class="loading-dirs">üìÅ This folder is empty or contains no subfolders</div>';
                    return;
                }
                
                // Render as folder grid
                content.innerHTML = `
                    <div class="folder-grid">
                        ${directories.map(dir => `
                            <div class="folder-card" onclick="navigateToPath('${dir.path.replace(/'/g, "\\'")}')">
                                <div class="dir-icon">${dir.icon}</div>
                                <div>
                                    <div class="dir-name">${dir.name}</div>
                                    <div class="dir-info">${dir.info}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                log(`üìÅ Loaded ${directories.length} folders from ${path}`, 'info');
                
            } catch (error) {
                content.innerHTML = '<div class="loading-dirs">‚ùå Error loading directories</div>';
                log(`‚ùå Failed to load directory listing: ${error.message}`, 'error');
            }
        }
        
        function navigateToPath(path) {
            // Determine drive and build path array
            let drive = '';
            let pathArray = [];
            
            if (path.startsWith('/mnt/c')) {
                drive = 'C:';
                pathArray = path.replace('/mnt/c/', '').split('/').filter(p => p);
            } else if (path.startsWith('/mnt/d')) {
                drive = 'D:';
                pathArray = path.replace('/mnt/d/', '').split('/').filter(p => p);
            } else if (path.startsWith('/home')) {
                drive = 'WSL';
                pathArray = path.replace('/home/', '').split('/').filter(p => p);
            }
            
            loadDirectoryListing(path, drive, pathArray);
        }
        
        async function getDirectoriesForPath(path) {
            // Enhanced directory structure
            const directoryMap = {
                '/mnt/c': [
                    { name: 'Users', path: '/mnt/c/Users', icon: 'üë•', info: 'User accounts' },
                    { name: 'Program Files', path: '/mnt/c/Program Files', icon: '‚öôÔ∏è', info: 'Installed programs' },
                    { name: 'Program Files (x86)', path: '/mnt/c/Program Files (x86)', icon: '‚öôÔ∏è', info: '32-bit programs' },
                    { name: 'Windows', path: '/mnt/c/Windows', icon: 'ü™ü', info: 'System files' },
                    { name: 'Go Fiber Router Backend', path: '/mnt/c/Go Fiber Router Backend', icon: 'üöÄ', info: 'Current project' }
                ],
                '/mnt/c/Users': [
                    { name: 'You', path: '/mnt/c/Users/You', icon: 'üë§', info: 'Your user profile' },
                    { name: 'Public', path: '/mnt/c/Users/Public', icon: 'üåê', info: 'Shared files' }
                ],
                '/mnt/c/Users/You': [
                    { name: 'Desktop', path: '/mnt/c/Users/You/Desktop', icon: 'üñ•Ô∏è', info: 'Desktop items' },
                    { name: 'Documents', path: '/mnt/c/Users/You/Documents', icon: 'üìÑ', info: 'Personal documents' },
                    { name: 'Downloads', path: '/mnt/c/Users/You/Downloads', icon: '‚¨áÔ∏è', info: 'Downloaded files' },
                    { name: 'Pictures', path: '/mnt/c/Users/You/Pictures', icon: 'üñºÔ∏è', info: 'Images and photos' },
                    { name: 'Videos', path: '/mnt/c/Users/You/Videos', icon: 'üé¨', info: 'Video files' },
                    { name: 'Projects', path: '/mnt/c/Users/You/Projects', icon: 'üíº', info: 'Development projects' }
                ],
                '/mnt/c/Users/You/Projects': [
                    { name: 'task-dashboard', path: '/mnt/c/Users/You/Projects/task-dashboard', icon: 'üìä', info: 'Task management dashboard' },
                    { name: 'react-app', path: '/mnt/c/Users/You/Projects/react-app', icon: '‚öõÔ∏è', info: 'React application' },
                    { name: 'node-backend', path: '/mnt/c/Users/You/Projects/node-backend', icon: 'üü¢', info: 'Node.js backend' },
                    { name: 'python-scripts', path: '/mnt/c/Users/You/Projects/python-scripts', icon: 'üêç', info: 'Python automation' },
                    { name: 'web-portfolio', path: '/mnt/c/Users/You/Projects/web-portfolio', icon: 'üåê', info: 'Personal website' }
                ],
                '/mnt/d': [
                    { name: 'Backup', path: '/mnt/d/Backup', icon: 'üíæ', info: 'System backups' },
                    { name: 'Projects', path: '/mnt/d/Projects', icon: 'üíº', info: 'Large projects' },
                    { name: 'Media', path: '/mnt/d/Media', icon: 'üéµ', info: 'Videos and music' }
                ],
                '/home': [
                    { name: 'ubuntu', path: '/home/ubuntu', icon: 'üêß', info: 'Ubuntu user home' },
                    { name: 'shared', path: '/home/shared', icon: 'ü§ù', info: 'Shared files' }
                ]
            };
            
            if (directoryMap[path]) {
                return directoryMap[path];
            }
            
            // Generate some example subdirectories for unknown paths
            const suggestions = [];
            if (path.includes('Desktop')) {
                suggestions.push(
                    { name: 'My Files', path: path + '/My Files', icon: 'üìÅ', info: 'Personal files' },
                    { name: 'Shortcuts', path: path + '/Shortcuts', icon: 'üîó', info: 'Desktop shortcuts' }
                );
            } else if (path.includes('Documents')) {
                suggestions.push(
                    { name: 'Work', path: path + '/Work', icon: 'üíº', info: 'Work documents' },
                    { name: 'Personal', path: path + '/Personal', icon: 'üë§', info: 'Personal files' }
                );
            }
            
            return suggestions;
        }
        
        function refreshBrowser() {
            if (currentBrowserPath) {
                navigateToPath(currentBrowserPath);
            } else {
                showDrives();
            }
        }
        
        function selectCurrentDirectory() {
            if (selectedDirectoryPath) {
                document.getElementById('newWorkspacePath').value = selectedDirectoryPath;
                closeBrowser();
                log(`üìÅ Selected directory: ${selectedDirectoryPath}`, 'success');
            }
        }
        
        async function changeWorkspace() {
            const newPath = document.getElementById('newWorkspacePath').value.trim();
            
            if (!newPath) {
                log('‚ùå Please enter a directory path', 'error');
                return;
            }
            
            log(`üîÑ Attempting to switch monitoring to: ${newPath}`, 'info');
            
            // Update the UI immediately for better user experience
            const workspaceElement = document.getElementById('workspacePath');
            const previousPath = workspaceElement.textContent;
            workspaceElement.textContent = newPath;
            log(`‚úÖ Workspace display updated to: ${newPath}`, 'success');
            
            try {
                // Try to notify the server about the workspace change
                const response = await fetch('http://localhost:3002/workspace/change', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        workspace: newPath
                    })
                });
                
                if (response.ok) {
                    log(`‚úÖ Server confirmed workspace change to: ${newPath}`, 'success');
                    hideWorkspaceChanger();
                    
                    // Reload workspace info to get fresh data
                    setTimeout(() => {
                        loadWorkspaceInfo();
                    }, 1000);
                    
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
                
            } catch (error) {
                log(`‚ö†Ô∏è Server workspace change failed: ${error.message}`, 'warning');
                log(`üí° UI updated but server requires restart for full monitoring`, 'info');
                log(`üí° For immediate full monitoring, use the "üöÄ Restart Server" button`, 'info');
                
                // Keep the UI updated even if server fails
                hideWorkspaceChanger();
            }
        }
        
        async function restartServerWithNewWorkspace() {
            const newPath = document.getElementById('newWorkspacePath').value.trim();
            
            if (!newPath) {
                log('‚ùå Please enter a directory path', 'error');
                return;
            }
            
            log(`üöÄ Initiating server restart with new workspace: ${newPath}`, 'info');
            log(`‚è≥ Step 1: Stopping current server...`, 'info');
            
            try {
                // First, try to gracefully stop the current server
                const stopResponse = await fetch('http://localhost:3002/server/stop', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (stopResponse.ok) {
                    log(`‚úÖ Server stop command sent successfully`, 'success');
                } else {
                    log(`‚ö†Ô∏è Server stop command failed, proceeding anyway`, 'warning');
                }
                
            } catch (error) {
                log(`‚ö†Ô∏è Could not send stop command: ${error.message}`, 'warning');
            }
            
            // Show restart instructions
            log(`üîÑ Step 2: Starting new server instance...`, 'info');
            log(`üíª Please run this command in your terminal:`, 'info');
            log(`   /usr/local/go/bin/go run main.go "${newPath}"`, 'info');
            log(`üîÑ Step 3: Refresh this dashboard once the new server starts`, 'info');
            
            // Update UI to show the new path
            const workspaceElement = document.getElementById('workspacePath');
            workspaceElement.textContent = newPath;
            
            // Copy command to clipboard for convenience
            try {
                const command = `/usr/local/go/bin/go run main.go "${newPath}"`;
                await navigator.clipboard.writeText(command);
                log(`üìã Restart command copied to clipboard!`, 'success');
                log(`üí° Using full Go path: /usr/local/go/bin/go`, 'info');
            } catch (clipError) {
                log(`üìã Could not copy to clipboard, but command is shown above`, 'info');
            }
            
            hideWorkspaceChanger();
            
            // Set up connection monitoring to detect when new server is ready
            monitorServerReconnection(newPath);
        }
        
        async function monitorServerReconnection(expectedPath) {
            log(`üîç Monitoring for server restart...`, 'info');
            let attemptCount = 0;
            const maxAttempts = 30; // 30 seconds
            
            const checkConnection = async () => {
                attemptCount++;
                
                try {
                    const response = await fetch('http://localhost:3002/health');
                    if (response.ok) {
                        log(`‚úÖ Server detected! Verifying workspace...`, 'success');
                        
                        // Small delay to let server fully initialize
                        setTimeout(() => {
                            loadWorkspaceInfo();
                            log(`üéâ Server restart complete! Dashboard refreshed.`, 'success');
                        }, 2000);
                        
                        return true;
                    }
                } catch (error) {
                    // Server not ready yet
                }
                
                if (attemptCount < maxAttempts) {
                    log(`üîç Waiting for server restart... (${attemptCount}/${maxAttempts})`, 'info');
                    setTimeout(checkConnection, 1000);
                } else {
                    log(`‚è∞ Server restart monitoring timed out`, 'warning');
                    log(`üí° Please manually refresh the dashboard when your server is ready`, 'info');
                }
                
                return false;
            };
            
            // Start monitoring after a brief delay
            setTimeout(checkConnection, 2000);
        }
        
        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                hideWorkspaceChanger();
            }
        });
        
        // Close modal on backdrop click
        document.getElementById('workspaceModal').addEventListener('click', function(e) {
            if (e.target === this) {
                hideWorkspaceChanger();
            }
        });
        
        // Enter key in input field
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('newWorkspacePath').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    changeWorkspace();
                }
            });
        });
    </script>

    <!-- Directory Browser Modal - Moved to body level for proper z-index -->
    <div id="browserBackdrop" class="browser-backdrop" style="display: none !important;" onclick="closeBrowser()"></div>
    <div id="directoryBrowser" class="directory-browser" style="display: none !important;">
        <div class="browser-header">
            <div class="breadcrumb-container">
                <button class="drives-btn" onclick="showDrives()" id="drivesBtn">üíæ Drives</button>
                <div class="breadcrumb" id="breadcrumb">
                    <span class="breadcrumb-item" onclick="showDrives()">This PC</span>
                </div>
            </div>
            <div class="browser-controls">
                <button class="refresh-btn" onclick="refreshBrowser()">üîÑ</button>
                <button class="close-btn" onclick="closeBrowser()">‚úï</button>
            </div>
        </div>
        <div class="browser-body">
            <div class="browser-sidebar">
                <div class="quick-access">
                    <div class="section-title">Quick Access</div>
                    <div class="quick-item" onclick="navigateToQuick('Desktop')">üñ•Ô∏è Desktop</div>
                    <div class="quick-item" onclick="navigateToQuick('Documents')">üìÑ Documents</div>
                    <div class="quick-item" onclick="navigateToQuick('Downloads')">‚¨áÔ∏è Downloads</div>
                    <div class="quick-item" onclick="navigateToQuick('Projects')">üíº Projects</div>
                </div>
                <div class="drives-section">
                    <div class="section-title">Drives</div>
                    <div id="drivesList">
                        <div class="drive-item" onclick="navigateToDrive('C:')">üíø Local Disk (C:)</div>
                        <div class="drive-item" onclick="navigateToDrive('D:')">üíæ Data Drive (D:)</div>
                        <div class="drive-item" onclick="navigateToDrive('WSL')">üêß WSL Linux</div>
                    </div>
                </div>
            </div>
            <div class="browser-main">
                <div class="browser-content" id="browserContent">
                    <div class="loading-dirs">üíæ Select a drive or quick access folder to begin</div>
                </div>
            </div>
        </div>
        <div class="browser-actions">
            <div class="selected-path" id="selectedPathDisplay">No folder selected</div>
            <button class="select-btn" onclick="selectCurrentDirectory()" id="selectBtn" disabled>üìÅ Select This Folder</button>
        </div>
    </div>

</body>
</html> 